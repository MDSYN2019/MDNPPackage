"""
Author: Sang Young Noh
----------------------
Last Updated: 02/07/2021
------------------------
"""

import numpy as np 
import sys
from scipy.spatial import distance
import MDAnalysis
from MDAnalysis.analysis.distances import distance_array
from MDNPPackage.utils.NP_UTILS import pandas_np, pandas_np_martini
from MDNPPackage.utils.NP_UTILS import read_martini_molecules

sys.path.append("..")

class NPConnect:
    def __init__(self, gros, firstatoms, lastatoms, spherelist, CG = 'CG', option = 'Plain'):
        self.gros = gros
        self.firstatoms = firstatoms
        self.lastatoms = lastatoms
        self.spherelist = spherelist
        self.option = option
        self.CG = CG
        
    def attach_ligands(ligandsmilesstring, firstatomlist, lastatomlist, spherelist, length = 1.0, option = 'Plain'):
        """ This function is utilized to place the smiles description of the ligand(s). 
        
        e.g use for the case of a plain ligand functionalized NP: 
    
        LigandSmilesStrings = ['C1=C(C=CC=C1)CS[H]']
        PandasNPDataframe = AttachLigands(LigandSmilesStrings, ['S7'], ['C4'], SphereList)

        e.g use for the case of a Janus or Striped NP:
    
        LigandSmilesStrings = ['C1=C(C=CC=C1)CS[H]']
        PandasNPDataframe = AttachLigands(LisphegandSmilesStrings, ['S7', 'S0'], ['C4', 'O3'], SphereList)
       
        Args:
        LigandSmilesString: 
            smiles of the ligand we want to attach. We want to give a list 
            as we want to have the options of attaching the ligands onto 
            a Janus or Striped NP 
        FirstAtomList:
            Name of the first atoms in the ligands
        LastAtomList: 
            Name of the last atoms in the ligands 
        SphereList:
            The core which has been generated by GenerateCore function 
        option (default = 'plain'):
             The type of NP we want to generate. 
        """
        # If the option is 'Plain' - we create a simple Nanoparticle without any patterns included  

        if self.option == 'Plain':
            
            ligand, core = pandas_np(ligandsmilesstring[0], firstatomlist[0], 
                                              lastatomlist[0], self.spherelist[0], 'Ligand1', 'Core', Length)
            total = core.append(ligand)
            return total 
    
        # If the option is 'Janus' or 'Striped', then we have to include the different 
        # ligands.  We have two entries of ligands we need to take into account 
        if self.option == 'Janus' or self.option == 'Striped':

            # If the option is 'Janus' or 'Striped', then we have to include the different 
            # ligands.  We have two entries of ligands we need to take into account 
            ligandI, coreI = pandas_np(ligandsmilesstring[0], firstatomlist[0], 
                                              lastatomlist[0], self.spherelist[0], 'Ligand1', 'Core', Length)            
            ligandII, coreII = pandas_np(ligandsmilesstring[1], firstatomlist[1], 
                                                lastatomlist[1], self.spherelist[1], 'Ligand2', 'Core', Length)
            # Append Core with Ligands
            maincore = coreI.append(coreII)
            # Add index to the core 
            ligands = ligandI.append(ligandII)
            # Add index to the ligands 
            total = maincore.append(ligands)
            total['index'] = Total.index
            total = total.reset_index()
            
            return total

    def return_ordered_coordinates(self):
        """
        """
        if self.option == 'Plain': 

            molecule, transformationlist, ligandalignmentvector = read_martini_molecules(
                self.gros[0], self.firstatoms[0], self.lastatoms[0])
            
            coordinatesligand, coordinatescore = pandas_np_martini(molecule, ligandalignmentvector, 
                                              transformationlist, self.spherelist[0], 'Lig1', 'Core')
            coordinates = coordinatesligand.append(coordinatescore)
            coordinates['index'] = coordinates.index
            coordinates = coordinates.reset_index()
            return coordinates
        
        if self.option == 'Janus' or self.option == 'Striped':

            # First ligand 
            moleculeI, transformationlistI, ligandalignmentvectorI = read_martini_molecules(
                self.gros[0], self.firstatoms[0], self.lastatoms[0])
            # Second Ligand 
            moleculeII, transformationlistII, ligandalignmentvectorII = read_martini_molecules(
                self.gros[1], self.firstatoms[1], self.lastatoms[1])
            coordinatesligandI, coordinatescoreI = pandas_np_martini(moleculeI, ligandalignmentvectorI, 
                                                                             transformationlistI, self.spherelist[0], 'Lig1', 'Core')
            coordinatesligandII, coordinatescoreII = pandas_np_martini(moleculeII, ligandalignmentvectorII, 
                                                                               transformationlistII, self.spherelist[1], 'Lig2', 'Core')
            coordinates = coordinatescoreI.append(coordinatescoreII)
            coordinates = coordinates.append(coordinatesligandI)
            coordinates = coordinates.append(coordinatesligandII)
            # reset index and allocate index column 
            coordinates['index'] = coordinates.index
            coordinates = coordinates.reset_index()
            return coordinates

    def attach_ligands_martini(self):
        """ 
        Here, we follow the same logic as the the AttachLigands to create a 
        Martini version of it. We are currently only using the Martini3 
        small molecules dictionary to create the martini ligands 
        """
        if self.option == 'Plain': 
            molecule, transformationlist, ligandalignmentvector = read_martini_molecules(
                self.gros[0], self.firstatoms[0], self.lastatoms[0])
        
            mollen = len(molecule)
            coordinates = self.return_ordered_coordinates()
            skippedligandfromspherelist = coordinates[:-len(self.spherelist[0])].iloc[::mollen, :]
            distlig = [[skippedligandfromspherelist['index'].iloc[i] + 1,  coordinates[-len(spherelist[0]):]['index'].iloc[i] + 1,
                         distance.euclidean(skippedligandfromspherelist.iloc[i][['X', 'Y', 'Z']].to_numpy(), self.spherelist[0][i])] for i in range(0, len(skippedligandfromspherelist))]
            attachmentbonds = [] 
            for bond in distlig:
                bondstring = f"{bond[0]} {bond[1]} 1 {bond[2] / 10} 10000"
                atachmentbonds.append(bondstring)
            return attachmentbonds 
    
        if self.option == 'Janus' or self.option == 'Striped':

            # First ligand 
            moleculeI, transformationlistI, ligandalignmentvectorI = read_martini_molecules(
                self.gros[0], self.firstatoms[0], self.lastatoms[0])
            # Second Ligand 
            moleculeII, transformationlistII, ligandalignmentvectorII = read_martini_molecules(
                self.gros[1], self.firstatoms[1], self.lastatoms[1])
            # Get length of first and second ligand
            mollenI, mollenII = len(moleculeI), len(moleculeII)
            coordinates = self.return_ordered_coordinates()
            coordinatesligandI, coordinatescoreI = pandas_np_martini(moleculeI, ligandalignmentvectorI, 
                                                                             transformationlistI, self.spherelist[0], 'Lig1', 'Core')
            coordinatesligandII, coordinatescoreII = pandas_np_martini(moleculeII, ligandalignmentvectorII, 
                                                                               transformationlistII, self.spherelist[1], 'Lig2', 'Core')
            
            # We return the coordinates of the first batch of NP atoms attached with ligands, 
            # and then attach the second batch of NP atoms attached with the second type of ligands 

            # Skip the spherelist part which is appended after the ligand list, 
            # and skip over by length list to get the headgroup index of the ligands

            completespherelistlen = len(self.spherelist[0]) + len(self.spherelist[1])
            skippedLigandIfromspherelist = coordinates[completespherelistlen:].iloc[0:len(coordinatesligandI):mollenI, :]
            skippedLigandIIfromspherelist = coordinates[len(coordinatesligandI) + completespherelistlen:].iloc[0:len(coordinatesligandII):mollenII, :]

            assert len(skippedLigandIfromspherelist) == len(self.spherelist[0])
            assert len(skippedLigandIIfromspherelist) == len(self.spherelist[1])

            attachmentbonds = []
            distligI = [[skippedLigandIfromspherelist['index'].iloc[i] + completespherelistlen + 1, 
                          coordinates[:-len(self.spherelist[0])]['index'].iloc[i] + 1,
                          distance.euclidean(skippedLigandIfromspherelist.iloc[i][['X', 'Y', 'Z']].to_numpy(),
                                            self.spherelist[0][i])] for i in range(0, len(skippedLigandIfromspherelist))]

            distligII = [[skippedLigandIIfromspherelist['index'].iloc[i] + completespherelistlen + len(coordinatesligandI) + 1, 
                           coordinates[len(self.spherelist[0]):-completespherelistlen]['index'].iloc[i] + len(self.spherelist[0]) + 1,
                           distance.euclidean(skippedLigandIIfromspherelist.iloc[i][['X', 'Y', 'Z']].to_numpy(), 
                                              self.spherelist[1][i])] for i in range(0, len(skippedLigandIIfromspherelist))]
            # Add the attachment bonds strings into a list to use later 
            attachmentbonds.append('; Ligand - NP bond')
            # add indices for ligand type 1
            for bond in distligI:
                bondstring = f"{bond[0]} {bond[1]} 1 {bond[2] / 10} 10000"
                attachmentbonds.append(bondstring)
            # add indices for ligand type II 
            for bond in distligII:
                bondstring = f"{bond[0]} {bond[1]} 1 {bond[2] / 10} 10000"
                attachmentbonds.append(bondstring)                
            return attachmentbonds
    
